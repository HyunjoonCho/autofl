[
    {
        "name": "test.helper.get_params#24",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.get_params(override=None)",
        "snippet": "def get_params(override=None):\n    PARAMETERS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)),\n                                   \"parameters.json\")\n    LOCAL_PARAMETERS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)),\n                                         \"local_parameters.json\")\n    with io.open(PARAMETERS_FILE, encoding='utf-8') as pf:\n        parameters = json.load(pf)\n    if os.path.exists(LOCAL_PARAMETERS_FILE):\n        with io.open(LOCAL_PARAMETERS_FILE, encoding='utf-8') as pf:\n            parameters.update(json.load(pf))\n    if override:\n        parameters.update(override)\n    return parameters",
        "begin_line": 24,
        "end_line": 36,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.try_rm#39",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.try_rm(filename)",
        "snippet": "def try_rm(filename):\n    \"\"\" Remove a file if it exists \"\"\"\n    try:\n        os.remove(filename)\n    except OSError as ose:\n        if ose.errno != errno.ENOENT:\n            raise",
        "begin_line": 39,
        "end_line": 45,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.report_warning#48",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.report_warning(message)",
        "snippet": "def report_warning(message):\n    '''\n    Print the message to stderr, it will be prefixed with 'WARNING:'\n    If stderr is a tty file the 'WARNING:' will be colored\n    '''\n    if sys.stderr.isatty() and compat_os_name != 'nt':\n        _msg_header = '\\033[0;33mWARNING:\\033[0m'\n    else:\n        _msg_header = 'WARNING:'\n    output = '%s %s\\n' % (_msg_header, message)\n    if 'b' in getattr(sys.stderr, 'mode', '') or sys.version_info[0] < 3:\n        output = output.encode(preferredencoding())\n    sys.stderr.write(output)",
        "begin_line": 48,
        "end_line": 60,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.__init__#64",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.__init__(self, override=None)",
        "snippet": "    def __init__(self, override=None):\n        # Different instances of the downloader can't share the same dictionary\n        # some test set the \"sublang\" parameter, which would break the md5 checks.\n        params = get_params(override=override)\n        super(FakeYDL, self).__init__(params, auto_init=False)\n        self.result = []",
        "begin_line": 64,
        "end_line": 69,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.to_screen#71",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.to_screen(self, s, skip_eol=None)",
        "snippet": "    def to_screen(self, s, skip_eol=None):\n        print(s)",
        "begin_line": 71,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.trouble#74",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.trouble(self, s, tb=None)",
        "snippet": "    def trouble(self, s, tb=None):\n        raise Exception(s)",
        "begin_line": 74,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.download#77",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.download(self, x)",
        "snippet": "    def download(self, x):\n        self.result.append(x)",
        "begin_line": 77,
        "end_line": 78,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.expect_warning#80",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.expect_warning(self, regex)",
        "snippet": "    def expect_warning(self, regex):\n        # Silence an expected warning matching a regex\n        old_report_warning = self.report_warning\n\n        def report_warning(self, message):\n            if re.match(regex, message):\n                return\n            old_report_warning(message)\n        self.report_warning = types.MethodType(report_warning, self)",
        "begin_line": 80,
        "end_line": 88,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.gettestcases#91",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.gettestcases(include_onlymatching=False)",
        "snippet": "def gettestcases(include_onlymatching=False):\n    for ie in youtube_dl.extractor.gen_extractors():\n        for tc in ie.get_testcases(include_onlymatching):\n            yield tc",
        "begin_line": 91,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.expect_value#100",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.expect_value(self, got, expected, field)",
        "snippet": "def expect_value(self, got, expected, field):\n    if isinstance(expected, compat_str) and expected.startswith('re:'):\n        match_str = expected[len('re:'):]\n        match_rex = re.compile(match_str)\n\n        self.assertTrue(\n            isinstance(got, compat_str),\n            'Expected a %s object, but got %s for field %s' % (\n                compat_str.__name__, type(got).__name__, field))\n        self.assertTrue(\n            match_rex.match(got),\n            'field %s (value: %r) should match %r' % (field, got, match_str))\n    elif isinstance(expected, compat_str) and expected.startswith('startswith:'):\n        start_str = expected[len('startswith:'):]\n        self.assertTrue(\n            isinstance(got, compat_str),\n            'Expected a %s object, but got %s for field %s' % (\n                compat_str.__name__, type(got).__name__, field))\n        self.assertTrue(\n            got.startswith(start_str),\n            'field %s (value: %r) should start with %r' % (field, got, start_str))\n    elif isinstance(expected, compat_str) and expected.startswith('contains:'):\n        contains_str = expected[len('contains:'):]\n        self.assertTrue(\n            isinstance(got, compat_str),\n            'Expected a %s object, but got %s for field %s' % (\n                compat_str.__name__, type(got).__name__, field))\n        self.assertTrue(\n            contains_str in got,\n            'field %s (value: %r) should contain %r' % (field, got, contains_str))\n    elif isinstance(expected, type):\n        self.assertTrue(\n            isinstance(got, expected),\n            'Expected type %r for field %s, but got value %r of type %r' % (expected, field, got, type(got)))\n    elif isinstance(expected, dict) and isinstance(got, dict):\n        expect_dict(self, got, expected)\n    elif isinstance(expected, list) and isinstance(got, list):\n        self.assertEqual(\n            len(expected), len(got),\n            'Expect a list of length %d, but got a list of length %d for field %s' % (\n                len(expected), len(got), field))\n        for index, (item_got, item_expected) in enumerate(zip(got, expected)):\n            type_got = type(item_got)\n            type_expected = type(item_expected)\n            self.assertEqual(\n                type_expected, type_got,\n                'Type mismatch for list item at index %d for field %s, expected %r, got %r' % (\n                    index, field, type_expected, type_got))\n            expect_value(self, item_got, item_expected, field)\n    else:\n        if isinstance(expected, compat_str) and expected.startswith('md5:'):\n            self.assertTrue(\n                isinstance(got, compat_str),\n                'Expected field %s to be a unicode object, but got value %r of type %r' % (field, got, type(got)))\n            got = 'md5:' + md5(got)\n        elif isinstance(expected, compat_str) and expected.startswith('mincount:'):\n            self.assertTrue(\n                isinstance(got, (list, dict)),\n                'Expected field %s to be a list or a dict, but it is of type %s' % (\n                    field, type(got).__name__))\n            expected_num = int(expected.partition(':')[2])\n            assertGreaterEqual(\n                self, len(got), expected_num,\n                'Expected %d items in field %s, but only got %d' % (expected_num, field, len(got)))\n            return\n        self.assertEqual(\n            expected, got,\n            'Invalid value for field %s, expected %r, got %r' % (field, expected, got))",
        "begin_line": 100,
        "end_line": 167,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.expect_dict#170",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.expect_dict(self, got_dict, expected_dict)",
        "snippet": "def expect_dict(self, got_dict, expected_dict):\n    for info_field, expected in expected_dict.items():\n        got = got_dict.get(info_field)\n        expect_value(self, got, expected, info_field)",
        "begin_line": 170,
        "end_line": 173,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.expect_info_dict#176",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.expect_info_dict(self, got_dict, expected_dict)",
        "snippet": "def expect_info_dict(self, got_dict, expected_dict):\n    expect_dict(self, got_dict, expected_dict)\n    # Check for the presence of mandatory fields\n    if got_dict.get('_type') not in ('playlist', 'multi_video'):\n        for key in ('id', 'url', 'title', 'ext'):\n            self.assertTrue(got_dict.get(key), 'Missing mandatory field %s' % key)\n    # Check for mandatory fields that are automatically set by YoutubeDL\n    for key in ['webpage_url', 'extractor', 'extractor_key']:\n        self.assertTrue(got_dict.get(key), 'Missing field: %s' % key)\n\n    # Are checkable fields missing from the test case definition?\n    test_info_dict = dict((key, value if not isinstance(value, compat_str) or len(value) < 250 else 'md5:' + md5(value))\n                          for key, value in got_dict.items()\n                          if value and key in ('id', 'title', 'description', 'uploader', 'upload_date', 'timestamp', 'uploader_id', 'location', 'age_limit'))\n    missing_keys = set(test_info_dict.keys()) - set(expected_dict.keys())\n    if missing_keys:\n        def _repr(v):\n            if isinstance(v, compat_str):\n                return \"'%s'\" % v.replace('\\\\', '\\\\\\\\').replace(\"'\", \"\\\\'\").replace('\\n', '\\\\n')\n            else:\n                return repr(v)\n        info_dict_str = ''\n        if len(missing_keys) != len(expected_dict):\n            info_dict_str += ''.join(\n                '    %s: %s,\\n' % (_repr(k), _repr(v))\n                for k, v in test_info_dict.items() if k not in missing_keys)\n\n            if info_dict_str:\n                info_dict_str += '\\n'\n        info_dict_str += ''.join(\n            '    %s: %s,\\n' % (_repr(k), _repr(test_info_dict[k]))\n            for k in missing_keys)\n        write_string(\n            '\\n\\'info_dict\\': {\\n' + info_dict_str + '},\\n', out=sys.stderr)\n        self.assertFalse(\n            missing_keys,\n            'Missing keys in test definition: %s' % (\n                ', '.join(sorted(missing_keys))))",
        "begin_line": 176,
        "end_line": 213,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.assertRegexpMatches#216",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.assertRegexpMatches(self, text, regexp, msg=None)",
        "snippet": "def assertRegexpMatches(self, text, regexp, msg=None):\n    if hasattr(self, 'assertRegexp'):\n        return self.assertRegexp(text, regexp, msg)\n    else:\n        m = re.match(regexp, text)\n        if not m:\n            note = 'Regexp didn\\'t match: %r not found' % (regexp)\n            if len(text) < 1000:\n                note += ' in %r' % text\n            if msg is None:\n                msg = note\n            else:\n                msg = note + ', ' + msg\n            self.assertTrue(m, msg)",
        "begin_line": 216,
        "end_line": 229,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.assertGreaterEqual#232",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.assertGreaterEqual(self, got, expected, msg=None)",
        "snippet": "def assertGreaterEqual(self, got, expected, msg=None):\n    if not (got >= expected):\n        if msg is None:\n            msg = '%r not greater than or equal to %r' % (got, expected)\n        self.assertTrue(got >= expected, msg)",
        "begin_line": 232,
        "end_line": 236,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.expect_warnings#239",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.expect_warnings(ydl, warnings_re)",
        "snippet": "def expect_warnings(ydl, warnings_re):\n    real_warning = ydl.report_warning\n\n    def _report_warning(w):\n        if not any(re.search(w_re, w) for w_re in warnings_re):\n            real_warning(w)\n\n    ydl.report_warning = _report_warning",
        "begin_line": 239,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.YDL.__init__#26",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.YDL",
        "signature": "test.test_YoutubeDL.YDL.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super(YDL, self).__init__(*args, **kwargs)\n        self.downloaded_info_dicts = []\n        self.msgs = []",
        "begin_line": 26,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.YDL.process_info#31",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.YDL",
        "signature": "test.test_YoutubeDL.YDL.process_info(self, info_dict)",
        "snippet": "    def process_info(self, info_dict):\n        self.downloaded_info_dicts.append(info_dict)",
        "begin_line": 31,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.YDL.to_screen#34",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.YDL",
        "signature": "test.test_YoutubeDL.YDL.to_screen(self, msg)",
        "snippet": "    def to_screen(self, msg):\n        self.msgs.append(msg)",
        "begin_line": 34,
        "end_line": 35,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL._make_result#38",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL",
        "signature": "test.test_YoutubeDL._make_result(formats, **kwargs)",
        "snippet": "def _make_result(formats, **kwargs):\n    res = {\n        'formats': formats,\n        'id': 'testid',\n        'title': 'testttitle',\n        'extractor': 'testex',\n        'extractor_key': 'TestEx',\n    }\n    res.update(**kwargs)\n    return res",
        "begin_line": 38,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_prefer_free_formats#51",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_prefer_free_formats(self)",
        "snippet": "    def test_prefer_free_formats(self):\n        # Same resolution => download webm\n        ydl = YDL()\n        ydl.params['prefer_free_formats'] = True\n        formats = [\n            {'ext': 'webm', 'height': 460, 'url': TEST_URL},\n            {'ext': 'mp4', 'height': 460, 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['ext'], 'webm')\n\n        # Different resolution => download best quality (mp4)\n        ydl = YDL()\n        ydl.params['prefer_free_formats'] = True\n        formats = [\n            {'ext': 'webm', 'height': 720, 'url': TEST_URL},\n            {'ext': 'mp4', 'height': 1080, 'url': TEST_URL},\n        ]\n        info_dict['formats'] = formats\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['ext'], 'mp4')\n\n        # No prefer_free_formats => prefer mp4 and flv for greater compatibility\n        ydl = YDL()\n        ydl.params['prefer_free_formats'] = False\n        formats = [\n            {'ext': 'webm', 'height': 720, 'url': TEST_URL},\n            {'ext': 'mp4', 'height': 720, 'url': TEST_URL},\n            {'ext': 'flv', 'height': 720, 'url': TEST_URL},\n        ]\n        info_dict['formats'] = formats\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['ext'], 'mp4')\n\n        ydl = YDL()\n        ydl.params['prefer_free_formats'] = False\n        formats = [\n            {'ext': 'flv', 'height': 720, 'url': TEST_URL},\n            {'ext': 'webm', 'height': 720, 'url': TEST_URL},\n        ]\n        info_dict['formats'] = formats\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['ext'], 'flv')",
        "begin_line": 51,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_selection#108",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_selection(self)",
        "snippet": "    def test_format_selection(self):\n        formats = [\n            {'format_id': '35', 'ext': 'mp4', 'preference': 1, 'url': TEST_URL},\n            {'format_id': 'example-with-dashes', 'ext': 'webm', 'preference': 1, 'url': TEST_URL},\n            {'format_id': '45', 'ext': 'webm', 'preference': 2, 'url': TEST_URL},\n            {'format_id': '47', 'ext': 'webm', 'preference': 3, 'url': TEST_URL},\n            {'format_id': '2', 'ext': 'flv', 'preference': 4, 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': '20/47'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '47')\n\n        ydl = YDL({'format': '20/71/worst'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '35')\n\n        ydl = YDL()\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '2')\n\n        ydl = YDL({'format': 'webm/mp4'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '47')\n\n        ydl = YDL({'format': '3gp/40/mp4'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '35')\n\n        ydl = YDL({'format': 'example-with-dashes'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'example-with-dashes')",
        "begin_line": 108,
        "end_line": 146,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_audio#148",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_audio(self)",
        "snippet": "    def test_format_selection_audio(self):\n        formats = [\n            {'format_id': 'audio-low', 'ext': 'webm', 'preference': 1, 'vcodec': 'none', 'url': TEST_URL},\n            {'format_id': 'audio-mid', 'ext': 'webm', 'preference': 2, 'vcodec': 'none', 'url': TEST_URL},\n            {'format_id': 'audio-high', 'ext': 'flv', 'preference': 3, 'vcodec': 'none', 'url': TEST_URL},\n            {'format_id': 'vid', 'ext': 'mp4', 'preference': 4, 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': 'bestaudio'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'audio-high')\n\n        ydl = YDL({'format': 'worstaudio'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'audio-low')\n\n        formats = [\n            {'format_id': 'vid-low', 'ext': 'mp4', 'preference': 1, 'url': TEST_URL},\n            {'format_id': 'vid-high', 'ext': 'mp4', 'preference': 2, 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': 'bestaudio/worstaudio/best'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'vid-high')",
        "begin_line": 148,
        "end_line": 176,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_audio_exts#178",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_audio_exts(self)",
        "snippet": "    def test_format_selection_audio_exts(self):\n        formats = [\n            {'format_id': 'mp3-64', 'ext': 'mp3', 'abr': 64, 'url': 'http://_', 'vcodec': 'none'},\n            {'format_id': 'ogg-64', 'ext': 'ogg', 'abr': 64, 'url': 'http://_', 'vcodec': 'none'},\n            {'format_id': 'aac-64', 'ext': 'aac', 'abr': 64, 'url': 'http://_', 'vcodec': 'none'},\n            {'format_id': 'mp3-32', 'ext': 'mp3', 'abr': 32, 'url': 'http://_', 'vcodec': 'none'},\n            {'format_id': 'aac-32', 'ext': 'aac', 'abr': 32, 'url': 'http://_', 'vcodec': 'none'},\n        ]\n\n        info_dict = _make_result(formats)\n        ydl = YDL({'format': 'best'})\n        ie = YoutubeIE(ydl)\n        ie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(copy.deepcopy(info_dict))\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'aac-64')\n\n        ydl = YDL({'format': 'mp3'})\n        ie = YoutubeIE(ydl)\n        ie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(copy.deepcopy(info_dict))\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'mp3-64')\n\n        ydl = YDL({'prefer_free_formats': True})\n        ie = YoutubeIE(ydl)\n        ie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(copy.deepcopy(info_dict))\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'ogg-64')",
        "begin_line": 178,
        "end_line": 207,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_video#209",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_video(self)",
        "snippet": "    def test_format_selection_video(self):\n        formats = [\n            {'format_id': 'dash-video-low', 'ext': 'mp4', 'preference': 1, 'acodec': 'none', 'url': TEST_URL},\n            {'format_id': 'dash-video-high', 'ext': 'mp4', 'preference': 2, 'acodec': 'none', 'url': TEST_URL},\n            {'format_id': 'vid', 'ext': 'mp4', 'preference': 3, 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': 'bestvideo'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'dash-video-high')\n\n        ydl = YDL({'format': 'worstvideo'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'dash-video-low')\n\n        ydl = YDL({'format': 'bestvideo[format_id^=dash][format_id$=low]'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'dash-video-low')\n\n        formats = [\n            {'format_id': 'vid-vcodec-dot', 'ext': 'mp4', 'preference': 1, 'vcodec': 'avc1.123456', 'acodec': 'none', 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': 'bestvideo[vcodec=avc1.123456]'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'vid-vcodec-dot')",
        "begin_line": 209,
        "end_line": 240,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_youtube_format_selection#242",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_youtube_format_selection(self)",
        "snippet": "    def test_youtube_format_selection(self):\n        order = [\n            '38', '37', '46', '22', '45', '35', '44', '18', '34', '43', '6', '5', '17', '36', '13',\n            # Apple HTTP Live Streaming\n            '96', '95', '94', '93', '92', '132', '151',\n            # 3D\n            '85', '84', '102', '83', '101', '82', '100',\n            # Dash video\n            '137', '248', '136', '247', '135', '246',\n            '245', '244', '134', '243', '133', '242', '160',\n            # Dash audio\n            '141', '172', '140', '171', '139',\n        ]\n\n        def format_info(f_id):\n            info = YoutubeIE._formats[f_id].copy()\n\n            # XXX: In real cases InfoExtractor._parse_mpd_formats() fills up 'acodec'\n            # and 'vcodec', while in tests such information is incomplete since\n            # commit a6c2c24479e5f4827ceb06f64d855329c0a6f593\n            # test_YoutubeDL.test_youtube_format_selection is broken without\n            # this fix\n            if 'acodec' in info and 'vcodec' not in info:\n                info['vcodec'] = 'none'\n            elif 'vcodec' in info and 'acodec' not in info:\n                info['acodec'] = 'none'\n\n            info['format_id'] = f_id\n            info['url'] = 'url:' + f_id\n            return info\n        formats_order = [format_info(f_id) for f_id in order]\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': 'bestvideo+bestaudio'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '137+141')\n        self.assertEqual(downloaded['ext'], 'mp4')\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': 'bestvideo[height>=999999]+bestaudio/best'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '38')\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': 'bestvideo/best,bestaudio'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['137', '141'])\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': '(bestvideo[ext=mp4],bestvideo[ext=webm])+bestaudio'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['137+141', '248+141'])\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': '(bestvideo[ext=mp4],bestvideo[ext=webm])[height<=720]+bestaudio'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['136+141', '247+141'])\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': '(bestvideo[ext=none]/bestvideo[ext=webm])+bestaudio'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['248+141'])\n\n        for f1, f2 in zip(formats_order, formats_order[1:]):\n            info_dict = _make_result([f1, f2], extractor='youtube')\n            ydl = YDL({'format': 'best/bestvideo'})\n            yie = YoutubeIE(ydl)\n            yie._sort_formats(info_dict['formats'])\n            ydl.process_ie_result(info_dict)\n            downloaded = ydl.downloaded_info_dicts[0]\n            self.assertEqual(downloaded['format_id'], f1['format_id'])\n\n            info_dict = _make_result([f2, f1], extractor='youtube')\n            ydl = YDL({'format': 'best/bestvideo'})\n            yie = YoutubeIE(ydl)\n            yie._sort_formats(info_dict['formats'])\n            ydl.process_ie_result(info_dict)\n            downloaded = ydl.downloaded_info_dicts[0]\n            self.assertEqual(downloaded['format_id'], f1['format_id'])",
        "begin_line": 242,
        "end_line": 338,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_audio_only_extractor_format_selection#340",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_audio_only_extractor_format_selection(self)",
        "snippet": "    def test_audio_only_extractor_format_selection(self):\n        # For extractors with incomplete formats (all formats are audio-only or\n        # video-only) best and worst should fallback to corresponding best/worst\n        # video-only or audio-only formats (as per\n        # https://github.com/rg3/youtube-dl/pull/5556)\n        formats = [\n            {'format_id': 'low', 'ext': 'mp3', 'preference': 1, 'vcodec': 'none', 'url': TEST_URL},\n            {'format_id': 'high', 'ext': 'mp3', 'preference': 2, 'vcodec': 'none', 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': 'best'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'high')\n\n        ydl = YDL({'format': 'worst'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'low')",
        "begin_line": 340,
        "end_line": 359,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_not_available#361",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_not_available(self)",
        "snippet": "    def test_format_not_available(self):\n        formats = [\n            {'format_id': 'regular', 'ext': 'mp4', 'height': 360, 'url': TEST_URL},\n            {'format_id': 'video', 'ext': 'mp4', 'height': 720, 'acodec': 'none', 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        # This must fail since complete video-audio format does not match filter\n        # and extractor does not provide incomplete only formats (i.e. only\n        # video-only or audio-only).\n        ydl = YDL({'format': 'best[height>360]'})\n        self.assertRaises(ExtractorError, ydl.process_ie_result, info_dict.copy())",
        "begin_line": 361,
        "end_line": 372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_invalid_format_specs#374",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_invalid_format_specs(self)",
        "snippet": "    def test_invalid_format_specs(self):\n        def assert_syntax_error(format_spec):\n            ydl = YDL({'format': format_spec})\n            info_dict = _make_result([{'format_id': 'foo', 'url': TEST_URL}])\n            self.assertRaises(SyntaxError, ydl.process_ie_result, info_dict)\n\n        assert_syntax_error('bestvideo,,best')\n        assert_syntax_error('+bestaudio')\n        assert_syntax_error('bestvideo+')\n        assert_syntax_error('/')",
        "begin_line": 374,
        "end_line": 383,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_filtering#385",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_filtering(self)",
        "snippet": "    def test_format_filtering(self):\n        formats = [\n            {'format_id': 'A', 'filesize': 500, 'width': 1000},\n            {'format_id': 'B', 'filesize': 1000, 'width': 500},\n            {'format_id': 'C', 'filesize': 1000, 'width': 400},\n            {'format_id': 'D', 'filesize': 2000, 'width': 600},\n            {'format_id': 'E', 'filesize': 3000},\n            {'format_id': 'F'},\n            {'format_id': 'G', 'filesize': 1000000},\n        ]\n        for f in formats:\n            f['url'] = 'http://_/'\n            f['ext'] = 'unknown'\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': 'best[filesize<3000]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'D')\n\n        ydl = YDL({'format': 'best[filesize<=3000]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'E')\n\n        ydl = YDL({'format': 'best[filesize <= ? 3000]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'F')\n\n        ydl = YDL({'format': 'best [filesize = 1000] [width>450]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'B')\n\n        ydl = YDL({'format': 'best [filesize = 1000] [width!=450]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'C')\n\n        ydl = YDL({'format': '[filesize>?1]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'G')\n\n        ydl = YDL({'format': '[filesize<1M]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'E')\n\n        ydl = YDL({'format': '[filesize<1MiB]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'G')\n\n        ydl = YDL({'format': 'all[width>=400][width<=600]'})\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['B', 'C', 'D'])\n\n        ydl = YDL({'format': 'best[height<40]'})\n        try:\n            ydl.process_ie_result(info_dict)\n        except ExtractorError:\n            pass\n        self.assertEqual(ydl.downloaded_info_dicts, [])",
        "begin_line": 385,
        "end_line": 450,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_subtitles#454",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_subtitles(self)",
        "snippet": "    def test_subtitles(self):\n        def s_formats(lang, autocaption=False):\n            return [{\n                'ext': ext,\n                'url': 'http://localhost/video.%s.%s' % (lang, ext),\n                '_auto': autocaption,\n            } for ext in ['vtt', 'srt', 'ass']]\n        subtitles = dict((l, s_formats(l)) for l in ['en', 'fr', 'es'])\n        auto_captions = dict((l, s_formats(l, True)) for l in ['it', 'pt', 'es'])\n        info_dict = {\n            'id': 'test',\n            'title': 'Test',\n            'url': 'http://localhost/video.mp4',\n            'subtitles': subtitles,\n            'automatic_captions': auto_captions,\n            'extractor': 'TEST',\n        }\n\n        def get_info(params={}):\n            params.setdefault('simulate', True)\n            ydl = YDL(params)\n            ydl.report_warning = lambda *args, **kargs: None\n            return ydl.process_video_result(info_dict, download=False)\n\n        result = get_info()\n        self.assertFalse(result.get('requested_subtitles'))\n        self.assertEqual(result['subtitles'], subtitles)\n        self.assertEqual(result['automatic_captions'], auto_captions)\n\n        result = get_info({'writesubtitles': True})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), set(['en']))\n        self.assertTrue(subs['en'].get('data') is None)\n        self.assertEqual(subs['en']['ext'], 'ass')\n\n        result = get_info({'writesubtitles': True, 'subtitlesformat': 'foo/srt'})\n        subs = result['requested_subtitles']\n        self.assertEqual(subs['en']['ext'], 'srt')\n\n        result = get_info({'writesubtitles': True, 'subtitleslangs': ['es', 'fr', 'it']})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), set(['es', 'fr']))\n\n        result = get_info({'writesubtitles': True, 'writeautomaticsub': True, 'subtitleslangs': ['es', 'pt']})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), set(['es', 'pt']))\n        self.assertFalse(subs['es']['_auto'])\n        self.assertTrue(subs['pt']['_auto'])\n\n        result = get_info({'writeautomaticsub': True, 'subtitleslangs': ['es', 'pt']})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), set(['es', 'pt']))\n        self.assertTrue(subs['es']['_auto'])\n        self.assertTrue(subs['pt']['_auto'])",
        "begin_line": 454,
        "end_line": 511,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_add_extra_info#513",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_add_extra_info(self)",
        "snippet": "    def test_add_extra_info(self):\n        test_dict = {\n            'extractor': 'Foo',\n        }\n        extra_info = {\n            'extractor': 'Bar',\n            'playlist': 'funny videos',\n        }\n        YDL.add_extra_info(test_dict, extra_info)\n        self.assertEqual(test_dict['extractor'], 'Foo')\n        self.assertEqual(test_dict['playlist'], 'funny videos')",
        "begin_line": 513,
        "end_line": 523,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_prepare_filename#525",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_prepare_filename(self)",
        "snippet": "    def test_prepare_filename(self):\n        info = {\n            'id': '1234',\n            'ext': 'mp4',\n            'width': None,\n            'height': 1080,\n            'title1': '$PATH',\n            'title2': '%PATH%',\n        }\n\n        def fname(templ):\n            ydl = YoutubeDL({'outtmpl': templ})\n            return ydl.prepare_filename(info)\n        self.assertEqual(fname('%(id)s.%(ext)s'), '1234.mp4')\n        self.assertEqual(fname('%(id)s-%(width)s.%(ext)s'), '1234-NA.mp4')\n        # Replace missing fields with 'NA'\n        self.assertEqual(fname('%(uploader_date)s-%(id)s.%(ext)s'), 'NA-1234.mp4')\n        self.assertEqual(fname('%(height)d.%(ext)s'), '1080.mp4')\n        self.assertEqual(fname('%(height)6d.%(ext)s'), '  1080.mp4')\n        self.assertEqual(fname('%(height)-6d.%(ext)s'), '1080  .mp4')\n        self.assertEqual(fname('%(height)06d.%(ext)s'), '001080.mp4')\n        self.assertEqual(fname('%(height) 06d.%(ext)s'), ' 01080.mp4')\n        self.assertEqual(fname('%(height)   06d.%(ext)s'), ' 01080.mp4')\n        self.assertEqual(fname('%(height)0 6d.%(ext)s'), ' 01080.mp4')\n        self.assertEqual(fname('%(height)0   6d.%(ext)s'), ' 01080.mp4')\n        self.assertEqual(fname('%(height)   0   6d.%(ext)s'), ' 01080.mp4')\n        self.assertEqual(fname('%%'), '%')\n        self.assertEqual(fname('%%%%'), '%%')\n        self.assertEqual(fname('%%(height)06d.%(ext)s'), '%(height)06d.mp4')\n        self.assertEqual(fname('%(width)06d.%(ext)s'), 'NA.mp4')\n        self.assertEqual(fname('%(width)06d.%%(ext)s'), 'NA.%(ext)s')\n        self.assertEqual(fname('%%(width)06d.%(ext)s'), '%(width)06d.mp4')\n        self.assertEqual(fname('Hello %(title1)s'), 'Hello $PATH')\n        self.assertEqual(fname('Hello %(title2)s'), 'Hello %PATH%')",
        "begin_line": 525,
        "end_line": 558,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_format_note#560",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_format_note(self)",
        "snippet": "    def test_format_note(self):\n        ydl = YoutubeDL()\n        self.assertEqual(ydl._format_note({}), '')\n        assertRegexpMatches(self, ydl._format_note({\n            'vbr': 10,\n        }), r'^\\s*10k$')\n        assertRegexpMatches(self, ydl._format_note({\n            'fps': 30,\n        }), r'^30fps$')",
        "begin_line": 560,
        "end_line": 568,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_postprocessors#570",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_postprocessors(self)",
        "snippet": "    def test_postprocessors(self):\n        filename = 'post-processor-testfile.mp4'\n        audiofile = filename + '.mp3'\n\n        class SimplePP(PostProcessor):\n            def run(self, info):\n                with open(audiofile, 'wt') as f:\n                    f.write('EXAMPLE')\n                return [info['filepath']], info\n\n        def run_pp(params, PP):\n            with open(filename, 'wt') as f:\n                f.write('EXAMPLE')\n            ydl = YoutubeDL(params)\n            ydl.add_post_processor(PP())\n            ydl.post_process(filename, {'filepath': filename})\n\n        run_pp({'keepvideo': True}, SimplePP)\n        self.assertTrue(os.path.exists(filename), '%s doesn\\'t exist' % filename)\n        self.assertTrue(os.path.exists(audiofile), '%s doesn\\'t exist' % audiofile)\n        os.unlink(filename)\n        os.unlink(audiofile)\n\n        run_pp({'keepvideo': False}, SimplePP)\n        self.assertFalse(os.path.exists(filename), '%s exists' % filename)\n        self.assertTrue(os.path.exists(audiofile), '%s doesn\\'t exist' % audiofile)\n        os.unlink(audiofile)\n\n        class ModifierPP(PostProcessor):\n            def run(self, info):\n                with open(info['filepath'], 'wt') as f:\n                    f.write('MODIFIED')\n                return [], info\n\n        run_pp({'keepvideo': False}, ModifierPP)\n        self.assertTrue(os.path.exists(filename), '%s doesn\\'t exist' % filename)\n        os.unlink(filename)",
        "begin_line": 570,
        "end_line": 606,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_match_filter#608",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_match_filter(self)",
        "snippet": "    def test_match_filter(self):\n        class FilterYDL(YDL):\n            def __init__(self, *args, **kwargs):\n                super(FilterYDL, self).__init__(*args, **kwargs)\n                self.params['simulate'] = True\n\n            def process_info(self, info_dict):\n                super(YDL, self).process_info(info_dict)\n\n            def _match_entry(self, info_dict, incomplete):\n                res = super(FilterYDL, self)._match_entry(info_dict, incomplete)\n                if res is None:\n                    self.downloaded_info_dicts.append(info_dict)\n                return res\n\n        first = {\n            'id': '1',\n            'url': TEST_URL,\n            'title': 'one',\n            'extractor': 'TEST',\n            'duration': 30,\n            'filesize': 10 * 1024,\n            'playlist_id': '42',\n            'uploader': \"\u8b8a\u614b\u598d\u5b57\u5e55\u7248 \u592a\u598d \u0442\u0435\u0441\u0442\",\n            'creator': \"\u0442\u0435\u0441\u0442 ' 123 ' \u0442\u0435\u0441\u0442--\",\n        }\n        second = {\n            'id': '2',\n            'url': TEST_URL,\n            'title': 'two',\n            'extractor': 'TEST',\n            'duration': 10,\n            'description': 'foo',\n            'filesize': 5 * 1024,\n            'playlist_id': '43',\n            'uploader': \"\u0442\u0435\u0441\u0442 123\",\n        }\n        videos = [first, second]\n\n        def get_videos(filter_=None):\n            ydl = FilterYDL({'match_filter': filter_})\n            for v in videos:\n                ydl.process_ie_result(v, download=True)\n            return [v['id'] for v in ydl.downloaded_info_dicts]\n\n        res = get_videos()\n        self.assertEqual(res, ['1', '2'])\n\n        def f(v):\n            if v['id'] == '1':\n                return None\n            else:\n                return 'Video id is not 1'\n        res = get_videos(f)\n        self.assertEqual(res, ['1'])\n\n        f = match_filter_func('duration < 30')\n        res = get_videos(f)\n        self.assertEqual(res, ['2'])\n\n        f = match_filter_func('description = foo')\n        res = get_videos(f)\n        self.assertEqual(res, ['2'])\n\n        f = match_filter_func('description =? foo')\n        res = get_videos(f)\n        self.assertEqual(res, ['1', '2'])\n\n        f = match_filter_func('filesize > 5KiB')\n        res = get_videos(f)\n        self.assertEqual(res, ['1'])\n\n        f = match_filter_func('playlist_id = 42')\n        res = get_videos(f)\n        self.assertEqual(res, ['1'])\n\n        f = match_filter_func('uploader = \"\u8b8a\u614b\u598d\u5b57\u5e55\u7248 \u592a\u598d \u0442\u0435\u0441\u0442\"')\n        res = get_videos(f)\n        self.assertEqual(res, ['1'])\n\n        f = match_filter_func('uploader != \"\u8b8a\u614b\u598d\u5b57\u5e55\u7248 \u592a\u598d \u0442\u0435\u0441\u0442\"')\n        res = get_videos(f)\n        self.assertEqual(res, ['2'])\n\n        f = match_filter_func('creator = \"\u0442\u0435\u0441\u0442 \\' 123 \\' \u0442\u0435\u0441\u0442--\"')\n        res = get_videos(f)\n        self.assertEqual(res, ['1'])\n\n        f = match_filter_func(\"creator = '\u0442\u0435\u0441\u0442 \\\\' 123 \\\\' \u0442\u0435\u0441\u0442--'\")\n        res = get_videos(f)\n        self.assertEqual(res, ['1'])\n\n        f = match_filter_func(r\"creator = '\u0442\u0435\u0441\u0442 \\' 123 \\' \u0442\u0435\u0441\u0442--' & duration > 30\")\n        res = get_videos(f)\n        self.assertEqual(res, [])",
        "begin_line": 608,
        "end_line": 702,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_playlist_items_selection#704",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_playlist_items_selection(self)",
        "snippet": "    def test_playlist_items_selection(self):\n        entries = [{\n            'id': compat_str(i),\n            'title': compat_str(i),\n            'url': TEST_URL,\n        } for i in range(1, 5)]\n        playlist = {\n            '_type': 'playlist',\n            'id': 'test',\n            'entries': entries,\n            'extractor': 'test:playlist',\n            'extractor_key': 'test:playlist',\n            'webpage_url': 'http://example.com',\n        }\n\n        def get_ids(params):\n            ydl = YDL(params)\n            # make a copy because the dictionary can be modified\n            ydl.process_ie_result(playlist.copy())\n            return [int(v['id']) for v in ydl.downloaded_info_dicts]\n\n        result = get_ids({})\n        self.assertEqual(result, [1, 2, 3, 4])\n\n        result = get_ids({'playlistend': 10})\n        self.assertEqual(result, [1, 2, 3, 4])\n\n        result = get_ids({'playlistend': 2})\n        self.assertEqual(result, [1, 2])\n\n        result = get_ids({'playliststart': 10})\n        self.assertEqual(result, [])\n\n        result = get_ids({'playliststart': 2})\n        self.assertEqual(result, [2, 3, 4])\n\n        result = get_ids({'playlist_items': '2-4'})\n        self.assertEqual(result, [2, 3, 4])\n\n        result = get_ids({'playlist_items': '2,4'})\n        self.assertEqual(result, [2, 4])\n\n        result = get_ids({'playlist_items': '10'})\n        self.assertEqual(result, [])",
        "begin_line": 704,
        "end_line": 747,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_urlopen_no_file_protocol#749",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_urlopen_no_file_protocol(self)",
        "snippet": "    def test_urlopen_no_file_protocol(self):\n        # see https://github.com/rg3/youtube-dl/issues/8227\n        ydl = YDL()\n        self.assertRaises(compat_urllib_error.URLError, ydl.urlopen, 'file:///etc/passwd')",
        "begin_line": 749,
        "end_line": 752,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_do_not_override_ie_key_in_url_transparent#754",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_do_not_override_ie_key_in_url_transparent(self)",
        "snippet": "    def test_do_not_override_ie_key_in_url_transparent(self):\n        ydl = YDL()\n\n        class Foo1IE(InfoExtractor):\n            _VALID_URL = r'foo1:'\n\n            def _real_extract(self, url):\n                return {\n                    '_type': 'url_transparent',\n                    'url': 'foo2:',\n                    'ie_key': 'Foo2',\n                    'title': 'foo1 title',\n                    'id': 'foo1_id',\n                }\n\n        class Foo2IE(InfoExtractor):\n            _VALID_URL = r'foo2:'\n\n            def _real_extract(self, url):\n                return {\n                    '_type': 'url',\n                    'url': 'foo3:',\n                    'ie_key': 'Foo3',\n                }\n\n        class Foo3IE(InfoExtractor):\n            _VALID_URL = r'foo3:'\n\n            def _real_extract(self, url):\n                return _make_result([{'url': TEST_URL}], title='foo3 title')\n\n        ydl.add_info_extractor(Foo1IE(ydl))\n        ydl.add_info_extractor(Foo2IE(ydl))\n        ydl.add_info_extractor(Foo3IE(ydl))\n        ydl.extract_info('foo1:')\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['url'], TEST_URL)\n        self.assertEqual(downloaded['title'], 'foo1 title')\n        self.assertEqual(downloaded['id'], 'testid')\n        self.assertEqual(downloaded['extractor'], 'testex')\n        self.assertEqual(downloaded['extractor_key'], 'TestEx')",
        "begin_line": 754,
        "end_line": 794,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.Foo1IE.test_do_not_override_ie_key_in_url_transparent#754",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.Foo1IE",
        "signature": "test.test_YoutubeDL.Foo1IE.test_do_not_override_ie_key_in_url_transparent(self)",
        "snippet": "    def test_do_not_override_ie_key_in_url_transparent(self):\n        ydl = YDL()\n\n        class Foo1IE(InfoExtractor):\n            _VALID_URL = r'foo1:'\n\n            def _real_extract(self, url):\n                return {\n                    '_type': 'url_transparent',\n                    'url': 'foo2:',\n                    'ie_key': 'Foo2',\n                    'title': 'foo1 title',\n                    'id': 'foo1_id',\n                }\n\n        class Foo2IE(InfoExtractor):\n            _VALID_URL = r'foo2:'\n\n            def _real_extract(self, url):\n                return {\n                    '_type': 'url',\n                    'url': 'foo3:',\n                    'ie_key': 'Foo3',\n                }\n\n        class Foo3IE(InfoExtractor):\n            _VALID_URL = r'foo3:'\n\n            def _real_extract(self, url):\n                return _make_result([{'url': TEST_URL}], title='foo3 title')\n\n        ydl.add_info_extractor(Foo1IE(ydl))\n        ydl.add_info_extractor(Foo2IE(ydl))\n        ydl.add_info_extractor(Foo3IE(ydl))\n        ydl.extract_info('foo1:')\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['url'], TEST_URL)\n        self.assertEqual(downloaded['title'], 'foo1 title')\n        self.assertEqual(downloaded['id'], 'testid')\n        self.assertEqual(downloaded['extractor'], 'testex')\n        self.assertEqual(downloaded['extractor_key'], 'TestEx')",
        "begin_line": 754,
        "end_line": 794,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.Foo1IE._real_extract#760",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.Foo1IE",
        "signature": "test.test_YoutubeDL.Foo1IE._real_extract(self, url)",
        "snippet": "            def _real_extract(self, url):\n                return {\n                    '_type': 'url_transparent',\n                    'url': 'foo2:',\n                    'ie_key': 'Foo2',\n                    'title': 'foo1 title',\n                    'id': 'foo1_id',\n                }",
        "begin_line": 760,
        "end_line": 767,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.Foo2IE.test_do_not_override_ie_key_in_url_transparent#754",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.Foo2IE",
        "signature": "test.test_YoutubeDL.Foo2IE.test_do_not_override_ie_key_in_url_transparent(self)",
        "snippet": "    def test_do_not_override_ie_key_in_url_transparent(self):\n        ydl = YDL()\n\n        class Foo1IE(InfoExtractor):\n            _VALID_URL = r'foo1:'\n\n            def _real_extract(self, url):\n                return {\n                    '_type': 'url_transparent',\n                    'url': 'foo2:',\n                    'ie_key': 'Foo2',\n                    'title': 'foo1 title',\n                    'id': 'foo1_id',\n                }\n\n        class Foo2IE(InfoExtractor):\n            _VALID_URL = r'foo2:'\n\n            def _real_extract(self, url):\n                return {\n                    '_type': 'url',\n                    'url': 'foo3:',\n                    'ie_key': 'Foo3',\n                }\n\n        class Foo3IE(InfoExtractor):\n            _VALID_URL = r'foo3:'\n\n            def _real_extract(self, url):\n                return _make_result([{'url': TEST_URL}], title='foo3 title')\n\n        ydl.add_info_extractor(Foo1IE(ydl))\n        ydl.add_info_extractor(Foo2IE(ydl))\n        ydl.add_info_extractor(Foo3IE(ydl))\n        ydl.extract_info('foo1:')\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['url'], TEST_URL)\n        self.assertEqual(downloaded['title'], 'foo1 title')\n        self.assertEqual(downloaded['id'], 'testid')\n        self.assertEqual(downloaded['extractor'], 'testex')\n        self.assertEqual(downloaded['extractor_key'], 'TestEx')",
        "begin_line": 754,
        "end_line": 794,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.Foo2IE._real_extract#772",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.Foo2IE",
        "signature": "test.test_YoutubeDL.Foo2IE._real_extract(self, url)",
        "snippet": "            def _real_extract(self, url):\n                return {\n                    '_type': 'url',\n                    'url': 'foo3:',\n                    'ie_key': 'Foo3',\n                }",
        "begin_line": 772,
        "end_line": 777,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.Foo3IE.test_do_not_override_ie_key_in_url_transparent#754",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.Foo3IE",
        "signature": "test.test_YoutubeDL.Foo3IE.test_do_not_override_ie_key_in_url_transparent(self)",
        "snippet": "    def test_do_not_override_ie_key_in_url_transparent(self):\n        ydl = YDL()\n\n        class Foo1IE(InfoExtractor):\n            _VALID_URL = r'foo1:'\n\n            def _real_extract(self, url):\n                return {\n                    '_type': 'url_transparent',\n                    'url': 'foo2:',\n                    'ie_key': 'Foo2',\n                    'title': 'foo1 title',\n                    'id': 'foo1_id',\n                }\n\n        class Foo2IE(InfoExtractor):\n            _VALID_URL = r'foo2:'\n\n            def _real_extract(self, url):\n                return {\n                    '_type': 'url',\n                    'url': 'foo3:',\n                    'ie_key': 'Foo3',\n                }\n\n        class Foo3IE(InfoExtractor):\n            _VALID_URL = r'foo3:'\n\n            def _real_extract(self, url):\n                return _make_result([{'url': TEST_URL}], title='foo3 title')\n\n        ydl.add_info_extractor(Foo1IE(ydl))\n        ydl.add_info_extractor(Foo2IE(ydl))\n        ydl.add_info_extractor(Foo3IE(ydl))\n        ydl.extract_info('foo1:')\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['url'], TEST_URL)\n        self.assertEqual(downloaded['title'], 'foo1 title')\n        self.assertEqual(downloaded['id'], 'testid')\n        self.assertEqual(downloaded['extractor'], 'testex')\n        self.assertEqual(downloaded['extractor_key'], 'TestEx')",
        "begin_line": 754,
        "end_line": 794,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.Foo3IE._real_extract#782",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.Foo3IE",
        "signature": "test.test_YoutubeDL.Foo3IE._real_extract(self, url)",
        "snippet": "            def _real_extract(self, url):\n                return _make_result([{'url': TEST_URL}], title='foo3 title')",
        "begin_line": 782,
        "end_line": 783,
        "comment": "",
        "is_bug": false
    }
]