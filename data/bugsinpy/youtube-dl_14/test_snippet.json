[
    {
        "name": "test.helper.get_params#25",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.get_params(override=None)",
        "snippet": "def get_params(override=None):\n    PARAMETERS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)),\n                                   \"parameters.json\")\n    LOCAL_PARAMETERS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)),\n                                         \"local_parameters.json\")\n    with io.open(PARAMETERS_FILE, encoding='utf-8') as pf:\n        parameters = json.load(pf)\n    if os.path.exists(LOCAL_PARAMETERS_FILE):\n        with io.open(LOCAL_PARAMETERS_FILE, encoding='utf-8') as pf:\n            parameters.update(json.load(pf))\n    if override:\n        parameters.update(override)\n    return parameters",
        "begin_line": 25,
        "end_line": 37,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.try_rm#40",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.try_rm(filename)",
        "snippet": "def try_rm(filename):\n    \"\"\" Remove a file if it exists \"\"\"\n    try:\n        os.remove(filename)\n    except OSError as ose:\n        if ose.errno != errno.ENOENT:\n            raise",
        "begin_line": 40,
        "end_line": 46,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.report_warning#49",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.report_warning(message)",
        "snippet": "def report_warning(message):\n    '''\n    Print the message to stderr, it will be prefixed with 'WARNING:'\n    If stderr is a tty file the 'WARNING:' will be colored\n    '''\n    if sys.stderr.isatty() and compat_os_name != 'nt':\n        _msg_header = '\\033[0;33mWARNING:\\033[0m'\n    else:\n        _msg_header = 'WARNING:'\n    output = '%s %s\\n' % (_msg_header, message)\n    if 'b' in getattr(sys.stderr, 'mode', '') or sys.version_info[0] < 3:\n        output = output.encode(preferredencoding())\n    sys.stderr.write(output)",
        "begin_line": 49,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.__init__#65",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.__init__(self, override=None)",
        "snippet": "    def __init__(self, override=None):\n        # Different instances of the downloader can't share the same dictionary\n        # some test set the \"sublang\" parameter, which would break the md5 checks.\n        params = get_params(override=override)\n        super(FakeYDL, self).__init__(params, auto_init=False)\n        self.result = []",
        "begin_line": 65,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.to_screen#72",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.to_screen(self, s, skip_eol=None)",
        "snippet": "    def to_screen(self, s, skip_eol=None):\n        print(s)",
        "begin_line": 72,
        "end_line": 73,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.trouble#75",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.trouble(self, s, tb=None)",
        "snippet": "    def trouble(self, s, tb=None):\n        raise Exception(s)",
        "begin_line": 75,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.download#78",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.download(self, x)",
        "snippet": "    def download(self, x):\n        self.result.append(x)",
        "begin_line": 78,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.expect_warning#81",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.expect_warning(self, regex)",
        "snippet": "    def expect_warning(self, regex):\n        # Silence an expected warning matching a regex\n        old_report_warning = self.report_warning\n\n        def report_warning(self, message):\n            if re.match(regex, message):\n                return\n            old_report_warning(message)\n        self.report_warning = types.MethodType(report_warning, self)",
        "begin_line": 81,
        "end_line": 89,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.gettestcases#92",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.gettestcases(include_onlymatching=False)",
        "snippet": "def gettestcases(include_onlymatching=False):\n    for ie in youtube_dl.extractor.gen_extractors():\n        for tc in ie.get_testcases(include_onlymatching):\n            yield tc",
        "begin_line": 92,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.expect_value#101",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.expect_value(self, got, expected, field)",
        "snippet": "def expect_value(self, got, expected, field):\n    if isinstance(expected, compat_str) and expected.startswith('re:'):\n        match_str = expected[len('re:'):]\n        match_rex = re.compile(match_str)\n\n        self.assertTrue(\n            isinstance(got, compat_str),\n            'Expected a %s object, but got %s for field %s' % (\n                compat_str.__name__, type(got).__name__, field))\n        self.assertTrue(\n            match_rex.match(got),\n            'field %s (value: %r) should match %r' % (field, got, match_str))\n    elif isinstance(expected, compat_str) and expected.startswith('startswith:'):\n        start_str = expected[len('startswith:'):]\n        self.assertTrue(\n            isinstance(got, compat_str),\n            'Expected a %s object, but got %s for field %s' % (\n                compat_str.__name__, type(got).__name__, field))\n        self.assertTrue(\n            got.startswith(start_str),\n            'field %s (value: %r) should start with %r' % (field, got, start_str))\n    elif isinstance(expected, compat_str) and expected.startswith('contains:'):\n        contains_str = expected[len('contains:'):]\n        self.assertTrue(\n            isinstance(got, compat_str),\n            'Expected a %s object, but got %s for field %s' % (\n                compat_str.__name__, type(got).__name__, field))\n        self.assertTrue(\n            contains_str in got,\n            'field %s (value: %r) should contain %r' % (field, got, contains_str))\n    elif isinstance(expected, type):\n        self.assertTrue(\n            isinstance(got, expected),\n            'Expected type %r for field %s, but got value %r of type %r' % (expected, field, got, type(got)))\n    elif isinstance(expected, dict) and isinstance(got, dict):\n        expect_dict(self, got, expected)\n    elif isinstance(expected, list) and isinstance(got, list):\n        self.assertEqual(\n            len(expected), len(got),\n            'Expect a list of length %d, but got a list of length %d for field %s' % (\n                len(expected), len(got), field))\n        for index, (item_got, item_expected) in enumerate(zip(got, expected)):\n            type_got = type(item_got)\n            type_expected = type(item_expected)\n            self.assertEqual(\n                type_expected, type_got,\n                'Type mismatch for list item at index %d for field %s, expected %r, got %r' % (\n                    index, field, type_expected, type_got))\n            expect_value(self, item_got, item_expected, field)\n    else:\n        if isinstance(expected, compat_str) and expected.startswith('md5:'):\n            self.assertTrue(\n                isinstance(got, compat_str),\n                'Expected field %s to be a unicode object, but got value %r of type %r' % (field, got, type(got)))\n            got = 'md5:' + md5(got)\n        elif isinstance(expected, compat_str) and re.match(r'^(?:min|max)?count:\\d+', expected):\n            self.assertTrue(\n                isinstance(got, (list, dict)),\n                'Expected field %s to be a list or a dict, but it is of type %s' % (\n                    field, type(got).__name__))\n            op, _, expected_num = expected.partition(':')\n            expected_num = int(expected_num)\n            if op == 'mincount':\n                assert_func = assertGreaterEqual\n                msg_tmpl = 'Expected %d items in field %s, but only got %d'\n            elif op == 'maxcount':\n                assert_func = assertLessEqual\n                msg_tmpl = 'Expected maximum %d items in field %s, but got %d'\n            elif op == 'count':\n                assert_func = assertEqual\n                msg_tmpl = 'Expected exactly %d items in field %s, but got %d'\n            else:\n                assert False\n            assert_func(\n                self, len(got), expected_num,\n                msg_tmpl % (expected_num, field, len(got)))\n            return\n        self.assertEqual(\n            expected, got,\n            'Invalid value for field %s, expected %r, got %r' % (field, expected, got))",
        "begin_line": 101,
        "end_line": 180,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.expect_dict#183",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.expect_dict(self, got_dict, expected_dict)",
        "snippet": "def expect_dict(self, got_dict, expected_dict):\n    for info_field, expected in expected_dict.items():\n        got = got_dict.get(info_field)\n        expect_value(self, got, expected, info_field)",
        "begin_line": 183,
        "end_line": 186,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.expect_info_dict#189",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.expect_info_dict(self, got_dict, expected_dict)",
        "snippet": "def expect_info_dict(self, got_dict, expected_dict):\n    expect_dict(self, got_dict, expected_dict)\n    # Check for the presence of mandatory fields\n    if got_dict.get('_type') not in ('playlist', 'multi_video'):\n        for key in ('id', 'url', 'title', 'ext'):\n            self.assertTrue(got_dict.get(key), 'Missing mandatory field %s' % key)\n    # Check for mandatory fields that are automatically set by YoutubeDL\n    for key in ['webpage_url', 'extractor', 'extractor_key']:\n        self.assertTrue(got_dict.get(key), 'Missing field: %s' % key)\n\n    # Are checkable fields missing from the test case definition?\n    test_info_dict = dict((key, value if not isinstance(value, compat_str) or len(value) < 250 else 'md5:' + md5(value))\n                          for key, value in got_dict.items()\n                          if value and key in ('id', 'title', 'description', 'uploader', 'upload_date', 'timestamp', 'uploader_id', 'location', 'age_limit'))\n    missing_keys = set(test_info_dict.keys()) - set(expected_dict.keys())\n    if missing_keys:\n        def _repr(v):\n            if isinstance(v, compat_str):\n                return \"'%s'\" % v.replace('\\\\', '\\\\\\\\').replace(\"'\", \"\\\\'\").replace('\\n', '\\\\n')\n            else:\n                return repr(v)\n        info_dict_str = ''\n        if len(missing_keys) != len(expected_dict):\n            info_dict_str += ''.join(\n                '    %s: %s,\\n' % (_repr(k), _repr(v))\n                for k, v in test_info_dict.items() if k not in missing_keys)\n\n            if info_dict_str:\n                info_dict_str += '\\n'\n        info_dict_str += ''.join(\n            '    %s: %s,\\n' % (_repr(k), _repr(test_info_dict[k]))\n            for k in missing_keys)\n        write_string(\n            '\\n\\'info_dict\\': {\\n' + info_dict_str + '},\\n', out=sys.stderr)\n        self.assertFalse(\n            missing_keys,\n            'Missing keys in test definition: %s' % (\n                ', '.join(sorted(missing_keys))))",
        "begin_line": 189,
        "end_line": 226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.assertRegexpMatches#229",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.assertRegexpMatches(self, text, regexp, msg=None)",
        "snippet": "def assertRegexpMatches(self, text, regexp, msg=None):\n    if hasattr(self, 'assertRegexp'):\n        return self.assertRegexp(text, regexp, msg)\n    else:\n        m = re.match(regexp, text)\n        if not m:\n            note = 'Regexp didn\\'t match: %r not found' % (regexp)\n            if len(text) < 1000:\n                note += ' in %r' % text\n            if msg is None:\n                msg = note\n            else:\n                msg = note + ', ' + msg\n            self.assertTrue(m, msg)",
        "begin_line": 229,
        "end_line": 242,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.assertGreaterEqual#245",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.assertGreaterEqual(self, got, expected, msg=None)",
        "snippet": "def assertGreaterEqual(self, got, expected, msg=None):\n    if not (got >= expected):\n        if msg is None:\n            msg = '%r not greater than or equal to %r' % (got, expected)\n        self.assertTrue(got >= expected, msg)",
        "begin_line": 245,
        "end_line": 249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.assertLessEqual#252",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.assertLessEqual(self, got, expected, msg=None)",
        "snippet": "def assertLessEqual(self, got, expected, msg=None):\n    if not (got <= expected):\n        if msg is None:\n            msg = '%r not less than or equal to %r' % (got, expected)\n        self.assertTrue(got <= expected, msg)",
        "begin_line": 252,
        "end_line": 256,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.assertEqual#259",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.assertEqual(self, got, expected, msg=None)",
        "snippet": "def assertEqual(self, got, expected, msg=None):\n    if not (got == expected):\n        if msg is None:\n            msg = '%r not equal to %r' % (got, expected)\n        self.assertTrue(got == expected, msg)",
        "begin_line": 259,
        "end_line": 263,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.expect_warnings#266",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.expect_warnings(ydl, warnings_re)",
        "snippet": "def expect_warnings(ydl, warnings_re):\n    real_warning = ydl.report_warning\n\n    def _report_warning(w):\n        if not any(re.search(w_re, w) for w_re in warnings_re):\n            real_warning(w)\n\n    ydl.report_warning = _report_warning",
        "begin_line": 266,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.http_server_port#276",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.http_server_port(httpd)",
        "snippet": "def http_server_port(httpd):\n    if os.name == 'java' and isinstance(httpd.socket, ssl.SSLSocket):\n        # In Jython SSLSocket is not a subclass of socket.socket\n        sock = httpd.socket.sock\n    else:\n        sock = httpd.socket\n    return sock.getsockname()[1]",
        "begin_line": 276,
        "end_line": 282,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_youtube_chapters.TestYoutubeChapters.test_youtube_chapters#266",
        "src_path": "test/test_youtube_chapters.py",
        "class_name": "test.test_youtube_chapters.TestYoutubeChapters",
        "signature": "test.test_youtube_chapters.TestYoutubeChapters.test_youtube_chapters(self)",
        "snippet": "    def test_youtube_chapters(self):\n        for description, duration, expected_chapters in self._TEST_CASES:\n            ie = YoutubeIE()\n            expect_value(\n                self, ie._extract_chapters_from_description(description, duration),\n                expected_chapters, None)",
        "begin_line": 266,
        "end_line": 271,
        "comment": "",
        "is_bug": false
    }
]