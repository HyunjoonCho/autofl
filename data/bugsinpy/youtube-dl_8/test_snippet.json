[
    {
        "name": "test.helper.get_params#21",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.get_params(override=None)",
        "snippet": "def get_params(override=None):\n    PARAMETERS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)),\n                                   \"parameters.json\")\n    with io.open(PARAMETERS_FILE, encoding='utf-8') as pf:\n        parameters = json.load(pf)\n    if override:\n        parameters.update(override)\n    return parameters",
        "begin_line": 21,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.try_rm#31",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.try_rm(filename)",
        "snippet": "def try_rm(filename):\n    \"\"\" Remove a file if it exists \"\"\"\n    try:\n        os.remove(filename)\n    except OSError as ose:\n        if ose.errno != errno.ENOENT:\n            raise",
        "begin_line": 31,
        "end_line": 37,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.report_warning#40",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.report_warning(message)",
        "snippet": "def report_warning(message):\n    '''\n    Print the message to stderr, it will be prefixed with 'WARNING:'\n    If stderr is a tty file the 'WARNING:' will be colored\n    '''\n    if sys.stderr.isatty() and os.name != 'nt':\n        _msg_header = '\\033[0;33mWARNING:\\033[0m'\n    else:\n        _msg_header = 'WARNING:'\n    output = '%s %s\\n' % (_msg_header, message)\n    if 'b' in getattr(sys.stderr, 'mode', '') or sys.version_info[0] < 3:\n        output = output.encode(preferredencoding())\n    sys.stderr.write(output)",
        "begin_line": 40,
        "end_line": 52,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.__init__#56",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.__init__(self, override=None)",
        "snippet": "    def __init__(self, override=None):\n        # Different instances of the downloader can't share the same dictionary\n        # some test set the \"sublang\" parameter, which would break the md5 checks.\n        params = get_params(override=override)\n        super(FakeYDL, self).__init__(params, auto_init=False)\n        self.result = []",
        "begin_line": 56,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.to_screen#63",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.to_screen(self, s, skip_eol=None)",
        "snippet": "    def to_screen(self, s, skip_eol=None):\n        print(s)",
        "begin_line": 63,
        "end_line": 64,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.trouble#66",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.trouble(self, s, tb=None)",
        "snippet": "    def trouble(self, s, tb=None):\n        raise Exception(s)",
        "begin_line": 66,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.download#69",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.download(self, x)",
        "snippet": "    def download(self, x):\n        self.result.append(x)",
        "begin_line": 69,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.FakeYDL.expect_warning#72",
        "src_path": "test/helper.py",
        "class_name": "test.helper.FakeYDL",
        "signature": "test.helper.FakeYDL.expect_warning(self, regex)",
        "snippet": "    def expect_warning(self, regex):\n        # Silence an expected warning matching a regex\n        old_report_warning = self.report_warning\n\n        def report_warning(self, message):\n            if re.match(regex, message):\n                return\n            old_report_warning(message)\n        self.report_warning = types.MethodType(report_warning, self)",
        "begin_line": 72,
        "end_line": 80,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.gettestcases#83",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.gettestcases(include_onlymatching=False)",
        "snippet": "def gettestcases(include_onlymatching=False):\n    for ie in youtube_dl.extractor.gen_extractors():\n        for tc in ie.get_testcases(include_onlymatching):\n            yield tc",
        "begin_line": 83,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.expect_info_dict#92",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.expect_info_dict(self, got_dict, expected_dict)",
        "snippet": "def expect_info_dict(self, got_dict, expected_dict):\n    for info_field, expected in expected_dict.items():\n        if isinstance(expected, compat_str) and expected.startswith('re:'):\n            got = got_dict.get(info_field)\n            match_str = expected[len('re:'):]\n            match_rex = re.compile(match_str)\n\n            self.assertTrue(\n                isinstance(got, compat_str),\n                'Expected a %s object, but got %s for field %s' % (\n                    compat_str.__name__, type(got).__name__, info_field))\n            self.assertTrue(\n                match_rex.match(got),\n                'field %s (value: %r) should match %r' % (info_field, got, match_str))\n        elif isinstance(expected, compat_str) and expected.startswith('startswith:'):\n            got = got_dict.get(info_field)\n            start_str = expected[len('startswith:'):]\n            self.assertTrue(\n                isinstance(got, compat_str),\n                'Expected a %s object, but got %s for field %s' % (\n                    compat_str.__name__, type(got).__name__, info_field))\n            self.assertTrue(\n                got.startswith(start_str),\n                'field %s (value: %r) should start with %r' % (info_field, got, start_str))\n        elif isinstance(expected, compat_str) and expected.startswith('contains:'):\n            got = got_dict.get(info_field)\n            contains_str = expected[len('contains:'):]\n            self.assertTrue(\n                isinstance(got, compat_str),\n                'Expected a %s object, but got %s for field %s' % (\n                    compat_str.__name__, type(got).__name__, info_field))\n            self.assertTrue(\n                contains_str in got,\n                'field %s (value: %r) should contain %r' % (info_field, got, contains_str))\n        elif isinstance(expected, type):\n            got = got_dict.get(info_field)\n            self.assertTrue(isinstance(got, expected),\n                            'Expected type %r for field %s, but got value %r of type %r' % (expected, info_field, got, type(got)))\n        else:\n            if isinstance(expected, compat_str) and expected.startswith('md5:'):\n                got = 'md5:' + md5(got_dict.get(info_field))\n            elif isinstance(expected, compat_str) and expected.startswith('mincount:'):\n                got = got_dict.get(info_field)\n                self.assertTrue(\n                    isinstance(got, list),\n                    'Expected field %s to be a list, but it is of type %s' % (\n                        info_field, type(got).__name__))\n                expected_num = int(expected.partition(':')[2])\n                assertGreaterEqual(\n                    self, len(got), expected_num,\n                    'Expected %d items in field %s, but only got %d' % (\n                        expected_num, info_field, len(got)\n                    )\n                )\n                continue\n            else:\n                got = got_dict.get(info_field)\n            self.assertEqual(expected, got,\n                             'invalid value for field %s, expected %r, got %r' % (info_field, expected, got))\n\n    # Check for the presence of mandatory fields\n    if got_dict.get('_type') not in ('playlist', 'multi_video'):\n        for key in ('id', 'url', 'title', 'ext'):\n            self.assertTrue(got_dict.get(key), 'Missing mandatory field %s' % key)\n    # Check for mandatory fields that are automatically set by YoutubeDL\n    for key in ['webpage_url', 'extractor', 'extractor_key']:\n        self.assertTrue(got_dict.get(key), 'Missing field: %s' % key)\n\n    # Are checkable fields missing from the test case definition?\n    test_info_dict = dict((key, value if not isinstance(value, compat_str) or len(value) < 250 else 'md5:' + md5(value))\n                          for key, value in got_dict.items()\n                          if value and key in ('id', 'title', 'description', 'uploader', 'upload_date', 'timestamp', 'uploader_id', 'location'))\n    missing_keys = set(test_info_dict.keys()) - set(expected_dict.keys())\n    if missing_keys:\n        def _repr(v):\n            if isinstance(v, compat_str):\n                return \"'%s'\" % v.replace('\\\\', '\\\\\\\\').replace(\"'\", \"\\\\'\").replace('\\n', '\\\\n')\n            else:\n                return repr(v)\n        info_dict_str = ''\n        if len(missing_keys) != len(expected_dict):\n            info_dict_str += ''.join(\n                '    %s: %s,\\n' % (_repr(k), _repr(v))\n                for k, v in test_info_dict.items() if k not in missing_keys)\n\n            if info_dict_str:\n                info_dict_str += '\\n'\n        info_dict_str += ''.join(\n            '    %s: %s,\\n' % (_repr(k), _repr(test_info_dict[k]))\n            for k in missing_keys)\n        write_string(\n            '\\n\\'info_dict\\': {\\n' + info_dict_str + '},\\n', out=sys.stderr)\n        self.assertFalse(\n            missing_keys,\n            'Missing keys in test definition: %s' % (\n                ', '.join(sorted(missing_keys))))",
        "begin_line": 92,
        "end_line": 187,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.assertRegexpMatches#190",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.assertRegexpMatches(self, text, regexp, msg=None)",
        "snippet": "def assertRegexpMatches(self, text, regexp, msg=None):\n    if hasattr(self, 'assertRegexp'):\n        return self.assertRegexp(text, regexp, msg)\n    else:\n        m = re.match(regexp, text)\n        if not m:\n            note = 'Regexp didn\\'t match: %r not found' % (regexp)\n            if len(text) < 1000:\n                note += ' in %r' % text\n            if msg is None:\n                msg = note\n            else:\n                msg = note + ', ' + msg\n            self.assertTrue(m, msg)",
        "begin_line": 190,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.assertGreaterEqual#206",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.assertGreaterEqual(self, got, expected, msg=None)",
        "snippet": "def assertGreaterEqual(self, got, expected, msg=None):\n    if not (got >= expected):\n        if msg is None:\n            msg = '%r not greater than or equal to %r' % (got, expected)\n        self.assertTrue(got >= expected, msg)",
        "begin_line": 206,
        "end_line": 210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helper.expect_warnings#213",
        "src_path": "test/helper.py",
        "class_name": "test.helper",
        "signature": "test.helper.expect_warnings(ydl, warnings_re)",
        "snippet": "def expect_warnings(ydl, warnings_re):\n    real_warning = ydl.report_warning\n\n    def _report_warning(w):\n        if not any(re.search(w_re, w) for w_re in warnings_re):\n            real_warning(w)\n\n    ydl.report_warning = _report_warning",
        "begin_line": 213,
        "end_line": 220,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.YDL.__init__#24",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.YDL",
        "signature": "test.test_YoutubeDL.YDL.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super(YDL, self).__init__(*args, **kwargs)\n        self.downloaded_info_dicts = []\n        self.msgs = []",
        "begin_line": 24,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.YDL.process_info#29",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.YDL",
        "signature": "test.test_YoutubeDL.YDL.process_info(self, info_dict)",
        "snippet": "    def process_info(self, info_dict):\n        self.downloaded_info_dicts.append(info_dict)",
        "begin_line": 29,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.YDL.to_screen#32",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.YDL",
        "signature": "test.test_YoutubeDL.YDL.to_screen(self, msg)",
        "snippet": "    def to_screen(self, msg):\n        self.msgs.append(msg)",
        "begin_line": 32,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL._make_result#36",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL",
        "signature": "test.test_YoutubeDL._make_result(formats, **kwargs)",
        "snippet": "def _make_result(formats, **kwargs):\n    res = {\n        'formats': formats,\n        'id': 'testid',\n        'title': 'testttitle',\n        'extractor': 'testex',\n    }\n    res.update(**kwargs)\n    return res",
        "begin_line": 36,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_prefer_free_formats#48",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_prefer_free_formats(self)",
        "snippet": "    def test_prefer_free_formats(self):\n        # Same resolution => download webm\n        ydl = YDL()\n        ydl.params['prefer_free_formats'] = True\n        formats = [\n            {'ext': 'webm', 'height': 460, 'url': TEST_URL},\n            {'ext': 'mp4', 'height': 460, 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['ext'], 'webm')\n\n        # Different resolution => download best quality (mp4)\n        ydl = YDL()\n        ydl.params['prefer_free_formats'] = True\n        formats = [\n            {'ext': 'webm', 'height': 720, 'url': TEST_URL},\n            {'ext': 'mp4', 'height': 1080, 'url': TEST_URL},\n        ]\n        info_dict['formats'] = formats\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['ext'], 'mp4')\n\n        # No prefer_free_formats => prefer mp4 and flv for greater compatibility\n        ydl = YDL()\n        ydl.params['prefer_free_formats'] = False\n        formats = [\n            {'ext': 'webm', 'height': 720, 'url': TEST_URL},\n            {'ext': 'mp4', 'height': 720, 'url': TEST_URL},\n            {'ext': 'flv', 'height': 720, 'url': TEST_URL},\n        ]\n        info_dict['formats'] = formats\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['ext'], 'mp4')\n\n        ydl = YDL()\n        ydl.params['prefer_free_formats'] = False\n        formats = [\n            {'ext': 'flv', 'height': 720, 'url': TEST_URL},\n            {'ext': 'webm', 'height': 720, 'url': TEST_URL},\n        ]\n        info_dict['formats'] = formats\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['ext'], 'flv')",
        "begin_line": 48,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_selection#105",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_selection(self)",
        "snippet": "    def test_format_selection(self):\n        formats = [\n            {'format_id': '35', 'ext': 'mp4', 'preference': 1, 'url': TEST_URL},\n            {'format_id': '45', 'ext': 'webm', 'preference': 2, 'url': TEST_URL},\n            {'format_id': '47', 'ext': 'webm', 'preference': 3, 'url': TEST_URL},\n            {'format_id': '2', 'ext': 'flv', 'preference': 4, 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': '20/47'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '47')\n\n        ydl = YDL({'format': '20/71/worst'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '35')\n\n        ydl = YDL()\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '2')\n\n        ydl = YDL({'format': 'webm/mp4'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '47')\n\n        ydl = YDL({'format': '3gp/40/mp4'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '35')",
        "begin_line": 105,
        "end_line": 137,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_audio#139",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_audio(self)",
        "snippet": "    def test_format_selection_audio(self):\n        formats = [\n            {'format_id': 'audio-low', 'ext': 'webm', 'preference': 1, 'vcodec': 'none', 'url': TEST_URL},\n            {'format_id': 'audio-mid', 'ext': 'webm', 'preference': 2, 'vcodec': 'none', 'url': TEST_URL},\n            {'format_id': 'audio-high', 'ext': 'flv', 'preference': 3, 'vcodec': 'none', 'url': TEST_URL},\n            {'format_id': 'vid', 'ext': 'mp4', 'preference': 4, 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': 'bestaudio'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'audio-high')\n\n        ydl = YDL({'format': 'worstaudio'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'audio-low')\n\n        formats = [\n            {'format_id': 'vid-low', 'ext': 'mp4', 'preference': 1, 'url': TEST_URL},\n            {'format_id': 'vid-high', 'ext': 'mp4', 'preference': 2, 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': 'bestaudio/worstaudio/best'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'vid-high')",
        "begin_line": 139,
        "end_line": 167,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_audio_exts#169",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_audio_exts(self)",
        "snippet": "    def test_format_selection_audio_exts(self):\n        formats = [\n            {'format_id': 'mp3-64', 'ext': 'mp3', 'abr': 64, 'url': 'http://_', 'vcodec': 'none'},\n            {'format_id': 'ogg-64', 'ext': 'ogg', 'abr': 64, 'url': 'http://_', 'vcodec': 'none'},\n            {'format_id': 'aac-64', 'ext': 'aac', 'abr': 64, 'url': 'http://_', 'vcodec': 'none'},\n            {'format_id': 'mp3-32', 'ext': 'mp3', 'abr': 32, 'url': 'http://_', 'vcodec': 'none'},\n            {'format_id': 'aac-32', 'ext': 'aac', 'abr': 32, 'url': 'http://_', 'vcodec': 'none'},\n        ]\n\n        info_dict = _make_result(formats)\n        ydl = YDL({'format': 'best'})\n        ie = YoutubeIE(ydl)\n        ie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(copy.deepcopy(info_dict))\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'aac-64')\n\n        ydl = YDL({'format': 'mp3'})\n        ie = YoutubeIE(ydl)\n        ie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(copy.deepcopy(info_dict))\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'mp3-64')\n\n        ydl = YDL({'prefer_free_formats': True})\n        ie = YoutubeIE(ydl)\n        ie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(copy.deepcopy(info_dict))\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'ogg-64')",
        "begin_line": 169,
        "end_line": 198,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_video#200",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_selection_video(self)",
        "snippet": "    def test_format_selection_video(self):\n        formats = [\n            {'format_id': 'dash-video-low', 'ext': 'mp4', 'preference': 1, 'acodec': 'none', 'url': TEST_URL},\n            {'format_id': 'dash-video-high', 'ext': 'mp4', 'preference': 2, 'acodec': 'none', 'url': TEST_URL},\n            {'format_id': 'vid', 'ext': 'mp4', 'preference': 3, 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': 'bestvideo'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'dash-video-high')\n\n        ydl = YDL({'format': 'worstvideo'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'dash-video-low')",
        "begin_line": 200,
        "end_line": 216,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_youtube_format_selection#218",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_youtube_format_selection(self)",
        "snippet": "    def test_youtube_format_selection(self):\n        order = [\n            '38', '37', '46', '22', '45', '35', '44', '18', '34', '43', '6', '5', '36', '17', '13',\n            # Apple HTTP Live Streaming\n            '96', '95', '94', '93', '92', '132', '151',\n            # 3D\n            '85', '84', '102', '83', '101', '82', '100',\n            # Dash video\n            '137', '248', '136', '247', '135', '246',\n            '245', '244', '134', '243', '133', '242', '160',\n            # Dash audio\n            '141', '172', '140', '171', '139',\n        ]\n\n        def format_info(f_id):\n            info = YoutubeIE._formats[f_id].copy()\n            info['format_id'] = f_id\n            info['url'] = 'url:' + f_id\n            return info\n        formats_order = [format_info(f_id) for f_id in order]\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': 'bestvideo+bestaudio'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '137+141')\n        self.assertEqual(downloaded['ext'], 'mp4')\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': 'bestvideo[height>=999999]+bestaudio/best'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '38')\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': 'bestvideo/best,bestaudio'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['137', '141'])\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': '(bestvideo[ext=mp4],bestvideo[ext=webm])+bestaudio'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['137+141', '248+141'])\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': '(bestvideo[ext=mp4],bestvideo[ext=webm])[height<=720]+bestaudio'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['136+141', '247+141'])\n\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': '(bestvideo[ext=none]/bestvideo[ext=webm])+bestaudio'})\n        yie = YoutubeIE(ydl)\n        yie._sort_formats(info_dict['formats'])\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['248+141'])\n\n        for f1, f2 in zip(formats_order, formats_order[1:]):\n            info_dict = _make_result([f1, f2], extractor='youtube')\n            ydl = YDL({'format': 'best/bestvideo'})\n            yie = YoutubeIE(ydl)\n            yie._sort_formats(info_dict['formats'])\n            ydl.process_ie_result(info_dict)\n            downloaded = ydl.downloaded_info_dicts[0]\n            self.assertEqual(downloaded['format_id'], f1['format_id'])\n\n            info_dict = _make_result([f2, f1], extractor='youtube')\n            ydl = YDL({'format': 'best/bestvideo'})\n            yie = YoutubeIE(ydl)\n            yie._sort_formats(info_dict['formats'])\n            ydl.process_ie_result(info_dict)\n            downloaded = ydl.downloaded_info_dicts[0]\n            self.assertEqual(downloaded['format_id'], f1['format_id'])",
        "begin_line": 218,
        "end_line": 303,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.format_info#232",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.format_info(f_id)",
        "snippet": "        def format_info(f_id):\n            info = YoutubeIE._formats[f_id].copy()\n            info['format_id'] = f_id\n            info['url'] = 'url:' + f_id\n            return info",
        "begin_line": 232,
        "end_line": 236,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestFormatSelection.test_format_filtering#305",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestFormatSelection",
        "signature": "test.test_YoutubeDL.TestFormatSelection.test_format_filtering(self)",
        "snippet": "    def test_format_filtering(self):\n        formats = [\n            {'format_id': 'A', 'filesize': 500, 'width': 1000},\n            {'format_id': 'B', 'filesize': 1000, 'width': 500},\n            {'format_id': 'C', 'filesize': 1000, 'width': 400},\n            {'format_id': 'D', 'filesize': 2000, 'width': 600},\n            {'format_id': 'E', 'filesize': 3000},\n            {'format_id': 'F'},\n            {'format_id': 'G', 'filesize': 1000000},\n        ]\n        for f in formats:\n            f['url'] = 'http://_/'\n            f['ext'] = 'unknown'\n        info_dict = _make_result(formats)\n\n        ydl = YDL({'format': 'best[filesize<3000]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'D')\n\n        ydl = YDL({'format': 'best[filesize<=3000]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'E')\n\n        ydl = YDL({'format': 'best[filesize <= ? 3000]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'F')\n\n        ydl = YDL({'format': 'best [filesize = 1000] [width>450]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'B')\n\n        ydl = YDL({'format': 'best [filesize = 1000] [width!=450]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'C')\n\n        ydl = YDL({'format': '[filesize>?1]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'G')\n\n        ydl = YDL({'format': '[filesize<1M]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'E')\n\n        ydl = YDL({'format': '[filesize<1MiB]'})\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'G')\n\n        ydl = YDL({'format': 'all[width>=400][width<=600]'})\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['B', 'C', 'D'])",
        "begin_line": 305,
        "end_line": 363,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_subtitles#367",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_subtitles(self)",
        "snippet": "    def test_subtitles(self):\n        def s_formats(lang, autocaption=False):\n            return [{\n                'ext': ext,\n                'url': 'http://localhost/video.%s.%s' % (lang, ext),\n                '_auto': autocaption,\n            } for ext in ['vtt', 'srt', 'ass']]\n        subtitles = dict((l, s_formats(l)) for l in ['en', 'fr', 'es'])\n        auto_captions = dict((l, s_formats(l, True)) for l in ['it', 'pt', 'es'])\n        info_dict = {\n            'id': 'test',\n            'title': 'Test',\n            'url': 'http://localhost/video.mp4',\n            'subtitles': subtitles,\n            'automatic_captions': auto_captions,\n            'extractor': 'TEST',\n        }\n\n        def get_info(params={}):\n            params.setdefault('simulate', True)\n            ydl = YDL(params)\n            ydl.report_warning = lambda *args, **kargs: None\n            return ydl.process_video_result(info_dict, download=False)\n\n        result = get_info()\n        self.assertFalse(result.get('requested_subtitles'))\n        self.assertEqual(result['subtitles'], subtitles)\n        self.assertEqual(result['automatic_captions'], auto_captions)\n\n        result = get_info({'writesubtitles': True})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), set(['en']))\n        self.assertTrue(subs['en'].get('data') is None)\n        self.assertEqual(subs['en']['ext'], 'ass')\n\n        result = get_info({'writesubtitles': True, 'subtitlesformat': 'foo/srt'})\n        subs = result['requested_subtitles']\n        self.assertEqual(subs['en']['ext'], 'srt')\n\n        result = get_info({'writesubtitles': True, 'subtitleslangs': ['es', 'fr', 'it']})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), set(['es', 'fr']))\n\n        result = get_info({'writesubtitles': True, 'writeautomaticsub': True, 'subtitleslangs': ['es', 'pt']})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), set(['es', 'pt']))\n        self.assertFalse(subs['es']['_auto'])\n        self.assertTrue(subs['pt']['_auto'])\n\n        result = get_info({'writeautomaticsub': True, 'subtitleslangs': ['es', 'pt']})\n        subs = result['requested_subtitles']\n        self.assertTrue(subs)\n        self.assertEqual(set(subs.keys()), set(['es', 'pt']))\n        self.assertTrue(subs['es']['_auto'])\n        self.assertTrue(subs['pt']['_auto'])",
        "begin_line": 367,
        "end_line": 424,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_add_extra_info#426",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_add_extra_info(self)",
        "snippet": "    def test_add_extra_info(self):\n        test_dict = {\n            'extractor': 'Foo',\n        }\n        extra_info = {\n            'extractor': 'Bar',\n            'playlist': 'funny videos',\n        }\n        YDL.add_extra_info(test_dict, extra_info)\n        self.assertEqual(test_dict['extractor'], 'Foo')\n        self.assertEqual(test_dict['playlist'], 'funny videos')",
        "begin_line": 426,
        "end_line": 436,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_prepare_filename#438",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_prepare_filename(self)",
        "snippet": "    def test_prepare_filename(self):\n        info = {\n            'id': '1234',\n            'ext': 'mp4',\n            'width': None,\n        }\n\n        def fname(templ):\n            ydl = YoutubeDL({'outtmpl': templ})\n            return ydl.prepare_filename(info)\n        self.assertEqual(fname('%(id)s.%(ext)s'), '1234.mp4')\n        self.assertEqual(fname('%(id)s-%(width)s.%(ext)s'), '1234-NA.mp4')\n        # Replace missing fields with 'NA'\n        self.assertEqual(fname('%(uploader_date)s-%(id)s.%(ext)s'), 'NA-1234.mp4')",
        "begin_line": 438,
        "end_line": 451,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_format_note#453",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_format_note(self)",
        "snippet": "    def test_format_note(self):\n        ydl = YoutubeDL()\n        self.assertEqual(ydl._format_note({}), '')\n        assertRegexpMatches(self, ydl._format_note({\n            'vbr': 10,\n        }), '^\\s*10k$')",
        "begin_line": 453,
        "end_line": 458,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_postprocessors#460",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_postprocessors(self)",
        "snippet": "    def test_postprocessors(self):\n        filename = 'post-processor-testfile.mp4'\n        audiofile = filename + '.mp3'\n\n        class SimplePP(PostProcessor):\n            def run(self, info):\n                with open(audiofile, 'wt') as f:\n                    f.write('EXAMPLE')\n                return [info['filepath']], info\n\n        def run_pp(params, PP):\n            with open(filename, 'wt') as f:\n                f.write('EXAMPLE')\n            ydl = YoutubeDL(params)\n            ydl.add_post_processor(PP())\n            ydl.post_process(filename, {'filepath': filename})\n\n        run_pp({'keepvideo': True}, SimplePP)\n        self.assertTrue(os.path.exists(filename), '%s doesn\\'t exist' % filename)\n        self.assertTrue(os.path.exists(audiofile), '%s doesn\\'t exist' % audiofile)\n        os.unlink(filename)\n        os.unlink(audiofile)\n\n        run_pp({'keepvideo': False}, SimplePP)\n        self.assertFalse(os.path.exists(filename), '%s exists' % filename)\n        self.assertTrue(os.path.exists(audiofile), '%s doesn\\'t exist' % audiofile)\n        os.unlink(audiofile)\n\n        class ModifierPP(PostProcessor):\n            def run(self, info):\n                with open(info['filepath'], 'wt') as f:\n                    f.write('MODIFIED')\n                return [], info\n\n        run_pp({'keepvideo': False}, ModifierPP)\n        self.assertTrue(os.path.exists(filename), '%s doesn\\'t exist' % filename)\n        os.unlink(filename)",
        "begin_line": 460,
        "end_line": 496,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_match_filter#498",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_match_filter(self)",
        "snippet": "    def test_match_filter(self):\n        class FilterYDL(YDL):\n            def __init__(self, *args, **kwargs):\n                super(FilterYDL, self).__init__(*args, **kwargs)\n                self.params['simulate'] = True\n\n            def process_info(self, info_dict):\n                super(YDL, self).process_info(info_dict)\n\n            def _match_entry(self, info_dict, incomplete):\n                res = super(FilterYDL, self)._match_entry(info_dict, incomplete)\n                if res is None:\n                    self.downloaded_info_dicts.append(info_dict)\n                return res\n\n        first = {\n            'id': '1',\n            'url': TEST_URL,\n            'title': 'one',\n            'extractor': 'TEST',\n            'duration': 30,\n            'filesize': 10 * 1024,\n        }\n        second = {\n            'id': '2',\n            'url': TEST_URL,\n            'title': 'two',\n            'extractor': 'TEST',\n            'duration': 10,\n            'description': 'foo',\n            'filesize': 5 * 1024,\n        }\n        videos = [first, second]\n\n        def get_videos(filter_=None):\n            ydl = FilterYDL({'match_filter': filter_})\n            for v in videos:\n                ydl.process_ie_result(v, download=True)\n            return [v['id'] for v in ydl.downloaded_info_dicts]\n\n        res = get_videos()\n        self.assertEqual(res, ['1', '2'])\n\n        def f(v):\n            if v['id'] == '1':\n                return None\n            else:\n                return 'Video id is not 1'\n        res = get_videos(f)\n        self.assertEqual(res, ['1'])\n\n        f = match_filter_func('duration < 30')\n        res = get_videos(f)\n        self.assertEqual(res, ['2'])\n\n        f = match_filter_func('description = foo')\n        res = get_videos(f)\n        self.assertEqual(res, ['2'])\n\n        f = match_filter_func('description =? foo')\n        res = get_videos(f)\n        self.assertEqual(res, ['1', '2'])\n\n        f = match_filter_func('filesize > 5KiB')\n        res = get_videos(f)\n        self.assertEqual(res, ['1'])",
        "begin_line": 498,
        "end_line": 563,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.test_YoutubeDL.TestYoutubeDL.test_playlist_items_selection#565",
        "src_path": "test/test_YoutubeDL.py",
        "class_name": "test.test_YoutubeDL.TestYoutubeDL",
        "signature": "test.test_YoutubeDL.TestYoutubeDL.test_playlist_items_selection(self)",
        "snippet": "    def test_playlist_items_selection(self):\n        entries = [{\n            'id': compat_str(i),\n            'title': compat_str(i),\n            'url': TEST_URL,\n        } for i in range(1, 5)]\n        playlist = {\n            '_type': 'playlist',\n            'id': 'test',\n            'entries': entries,\n            'extractor': 'test:playlist',\n            'extractor_key': 'test:playlist',\n            'webpage_url': 'http://example.com',\n        }\n\n        def get_ids(params):\n            ydl = YDL(params)\n            # make a copy because the dictionary can be modified\n            ydl.process_ie_result(playlist.copy())\n            return [int(v['id']) for v in ydl.downloaded_info_dicts]\n\n        result = get_ids({})\n        self.assertEqual(result, [1, 2, 3, 4])\n\n        result = get_ids({'playlistend': 10})\n        self.assertEqual(result, [1, 2, 3, 4])\n\n        result = get_ids({'playlistend': 2})\n        self.assertEqual(result, [1, 2])\n\n        result = get_ids({'playliststart': 10})\n        self.assertEqual(result, [])\n\n        result = get_ids({'playliststart': 2})\n        self.assertEqual(result, [2, 3, 4])\n\n        result = get_ids({'playlist_items': '2-4'})\n        self.assertEqual(result, [2, 3, 4])\n\n        result = get_ids({'playlist_items': '2,4'})\n        self.assertEqual(result, [2, 4])\n\n        result = get_ids({'playlist_items': '10'})\n        self.assertEqual(result, [])",
        "begin_line": 565,
        "end_line": 608,
        "comment": "",
        "is_bug": false
    }
]